const std = @import("std");
const host = @import("host");

// Backend executors
pub const zisk_executor = @import("executor/zisk.zig");
pub const ligero_executor = @import("executor/ligero.zig");

// Backend provers
pub const zisk_prover = @import("prover/zisk.zig");
pub const ligero_prover = @import("prover/ligero.zig");

/// Available backends for the runtime
pub const Backend = enum {
    zisk,
    ligero,

    /// Convert to host.Backend for input/output encoding
    pub fn toHostBackend(self: Backend) host.Backend {
        return switch (self) {
            .zisk => .zisk,
            .ligero => .ligero,
        };
    }
};

/// Result of executing a guest program (without proof)
pub const ExecutionResult = struct {
    allocator: std.mem.Allocator,
    /// Output values from the guest program (backend-aware)
    output: host.Output,
    /// Number of execution cycles (if available)
    cycles: ?u64,
    /// Raw stdout from the executor (for debugging)
    stdout: ?[]const u8,
    /// Raw stderr from the executor (for debugging)
    stderr: ?[]const u8,

    const Self = @This();

    pub fn deinit(self: *Self) void {
        self.output.deinit();
        if (self.stdout) |s| self.allocator.free(s);
        if (self.stderr) |s| self.allocator.free(s);
    }
};

/// Result of proving a guest program
pub const ProofResult = struct {
    allocator: std.mem.Allocator,
    /// Output values from the guest program (backend-aware)
    output: host.Output,
    /// Generated proof data
    proof: Proof,
    /// Time taken to generate proof (milliseconds)
    proof_time_ms: u64,
    /// Raw stdout from the prover (for debugging)
    stdout: ?[]const u8,
    /// Raw stderr from the prover (for debugging)
    stderr: ?[]const u8,

    const Self = @This();

    pub fn deinit(self: *Self) void {
        self.output.deinit();
        self.proof.deinit();
        if (self.stdout) |s| self.allocator.free(s);
        if (self.stderr) |s| self.allocator.free(s);
    }
};

/// Cryptographic proof generated by the prover
pub const Proof = struct {
    allocator: std.mem.Allocator,
    /// Raw proof bytes
    data: []const u8,
    /// Backend that generated this proof
    backend: Backend,

    const Self = @This();

    pub fn deinit(self: *Self) void {
        self.allocator.free(self.data);
    }

    /// Save proof to a file
    pub fn toFile(self: *const Self, path: []const u8) !void {
        const file = try std.fs.cwd().createFile(path, .{});
        defer file.close();
        try file.writeAll(self.data);
    }

    /// Load proof from a file
    pub fn fromFile(allocator: std.mem.Allocator, path: []const u8, backend: Backend) !Self {
        const file = try std.fs.cwd().openFile(path, .{});
        defer file.close();

        const data = try file.readToEndAlloc(allocator, 100 * 1024 * 1024); // 100MB max
        return Self{
            .allocator = allocator,
            .data = data,
            .backend = backend,
        };
    }
};

/// Internal result from executors (used by executor modules)
/// This is converted to ExecutionResult with host.Output in the Runtime API.
pub const ExecutorResult = struct {
    allocator: std.mem.Allocator,
    outputs: OutputData,
    cycles: ?u64,
    stdout: ?[]const u8,
    stderr: ?[]const u8,

    const Self = @This();

    pub fn deinit(self: *Self) void {
        self.outputs.deinit();
        if (self.stdout) |s| self.allocator.free(s);
        if (self.stderr) |s| self.allocator.free(s);
    }
};

/// Internal result from provers (used by prover modules)
pub const ProverResult = struct {
    allocator: std.mem.Allocator,
    outputs: OutputData,
    proof: Proof,
    proof_time_ms: u64,
    stdout: ?[]const u8,
    stderr: ?[]const u8,

    const Self = @This();

    pub fn deinit(self: *Self) void {
        self.outputs.deinit();
        self.proof.deinit();
        if (self.stdout) |s| self.allocator.free(s);
        if (self.stderr) |s| self.allocator.free(s);
    }
};

/// Output data from guest program execution (internal use)
/// For public API, use host.Output which is backend-aware.
pub const OutputData = struct {
    allocator: std.mem.Allocator,
    values: []u32,
    count: u32,

    const Self = @This();
    const MAX_OUTPUT_COUNT: usize = 64;

    /// Parse output from raw bytes (count + values format)
    pub fn fromBytes(allocator: std.mem.Allocator, bytes: []const u8) !Self {
        if (bytes.len < 4) {
            return error.InvalidOutputFormat;
        }

        const output_count = std.mem.readInt(u32, bytes[0..4], .little);

        if (output_count > MAX_OUTPUT_COUNT) {
            return error.TooManyOutputs;
        }

        const expected_size = 4 + (output_count * 4);
        if (bytes.len < expected_size) {
            return error.InvalidOutputFormat;
        }

        const values = try allocator.alloc(u32, output_count);
        errdefer allocator.free(values);

        for (0..output_count) |i| {
            const offset = 4 + (i * 4);
            values[i] = std.mem.readInt(u32, bytes[offset..][0..4], .little);
        }

        return Self{
            .allocator = allocator,
            .values = values,
            .count = output_count,
        };
    }

    /// Load output from a file (count + values format)
    pub fn fromFile(allocator: std.mem.Allocator, path: []const u8) !Self {
        const file = try std.fs.cwd().openFile(path, .{});
        defer file.close();

        const bytes = try file.readToEndAlloc(allocator, 1024 * 1024);
        defer allocator.free(bytes);

        return try fromBytes(allocator, bytes);
    }

    /// Parse raw output bytes (no count prefix, used by ziskemu)
    /// File size / 4 = number of u32 values
    pub fn fromRawBytes(allocator: std.mem.Allocator, bytes: []const u8) !Self {
        if (bytes.len % 4 != 0) {
            return error.InvalidOutputFormat;
        }

        const output_count: u32 = @intCast(bytes.len / 4);
        if (output_count > MAX_OUTPUT_COUNT) {
            return error.TooManyOutputs;
        }

        const values = try allocator.alloc(u32, output_count);
        errdefer allocator.free(values);

        for (0..output_count) |i| {
            const offset = i * 4;
            values[i] = std.mem.readInt(u32, bytes[offset..][0..4], .little);
        }

        return Self{
            .allocator = allocator,
            .values = values,
            .count = output_count,
        };
    }

    /// Load raw output from a file (no count prefix, used by ziskemu)
    pub fn fromRawFile(allocator: std.mem.Allocator, path: []const u8) !Self {
        const file = try std.fs.cwd().openFile(path, .{});
        defer file.close();

        const bytes = try file.readToEndAlloc(allocator, 1024 * 1024);
        defer allocator.free(bytes);

        return try fromRawBytes(allocator, bytes);
    }

    pub fn deinit(self: *Self) void {
        self.allocator.free(self.values);
    }

    /// Read a u32 output value at the given index
    pub fn read(self: *const Self, index: usize) u32 {
        if (index >= self.count) return 0;
        return self.values[index];
    }

    /// Read a u64 output value from two consecutive slots
    pub fn readU64(self: *const Self, index: usize) u64 {
        const low: u64 = self.read(index);
        const high: u64 = self.read(index + 1);
        return low | (high << 32);
    }

    /// Get all outputs as a slice
    pub fn slice(self: *const Self) []const u32 {
        return self.values[0..self.count];
    }
};

/// Runtime configuration options
pub const Options = struct {
    /// Backend to use (zisk or ligero)
    backend: Backend,
    /// Path to the compiled guest binary (ELF for zisk, WASM for ligero)
    guest_binary: []const u8,
    /// Enable proving (if false, only execution is supported)
    enable_proving: bool = false,

    // Tool path overrides (optional)
    /// Path to ziskemu binary (default: "ziskemu")
    ziskemu_path: ?[]const u8 = null,
    /// Path to cargo-zisk binary (default: "cargo-zisk")
    cargo_zisk_path: ?[]const u8 = null,
    /// Path to webgpu_prover binary (default: from ~/.ligero/bin/)
    webgpu_prover_path: ?[]const u8 = null,
    /// Path to webgpu_verifier binary (default: from ~/.ligero/bin/)
    webgpu_verifier_path: ?[]const u8 = null,

    // Execution options
    /// Maximum cycles before timeout (zisk only)
    max_cycles: ?u64 = null,

    // Ligero-specific options
    /// Path to Ligero shader directory
    shader_path: ?[]const u8 = null,
};

/// High-level runtime for executing and proving zkVM programs.
/// Thread-safe: multiple executions can run concurrently.
///
/// ## Basic usage
/// ```zig
/// var rt = try Runtime.init(allocator, .{
///     .backend = .zisk,
///     .guest_binary = "zig-out/bin/guest.elf",
/// });
/// defer rt.deinit();
///
/// // Create input using the runtime's backend
/// var input = rt.createInput();
/// defer input.deinit();
/// try input.write(@as(u64, 42));
///
/// const result = try rt.execute(null, try input.getPrivateBytes());
/// defer result.deinit();
/// ```
///
/// ## With public/private separation (Ligero)
/// ```zig
/// var rt = try Runtime.init(allocator, .{
///     .backend = .ligero,
///     .guest_binary = "guest.wasm",
/// });
/// defer rt.deinit();
///
/// var input = rt.createInput();
/// defer input.deinit();
/// try input.writePublic(@as(u64, expected_hash));
/// try input.writePrivate(@as(u64, secret_value));
///
/// const result = try rt.execute(
///     try input.getPublicBytes(),
///     try input.getPrivateBytes(),
/// );
/// defer result.deinit();
/// ```
pub const Runtime = struct {
    allocator: std.mem.Allocator,
    options: Options,
    guest_binary: []const u8,

    // Backend-specific executors/provers (lazily initialized)
    zisk_exec: ?zisk_executor.ZisKExecutor,
    zisk_prov: ?zisk_prover.ZisKProver,
    ligero_exec: ?ligero_executor.LigeroExecutor,
    ligero_prov: ?ligero_prover.LigeroProver,

    // Mutex for thread-safe operations
    mutex: std.Thread.Mutex,

    const Self = @This();

    /// Initialize a new runtime
    pub fn init(allocator: std.mem.Allocator, options: Options) !Self {
        const guest_binary = try allocator.dupe(u8, options.guest_binary);
        errdefer allocator.free(guest_binary);

        var self = Self{
            .allocator = allocator,
            .options = options,
            .guest_binary = guest_binary,
            .zisk_exec = null,
            .zisk_prov = null,
            .ligero_exec = null,
            .ligero_prov = null,
            .mutex = .{},
        };

        // Initialize backend executor
        switch (options.backend) {
            .zisk => {
                self.zisk_exec = try zisk_executor.ZisKExecutor.init(allocator, .{
                    .ziskemu_path = options.ziskemu_path,
                    .max_cycles = options.max_cycles,
                });
            },
            .ligero => {
                self.ligero_exec = try ligero_executor.LigeroExecutor.init(allocator, .{
                    .shader_path = options.shader_path,
                });
            },
        }

        // Initialize prover if enabled
        if (options.enable_proving) {
            switch (options.backend) {
                .zisk => {
                    self.zisk_prov = try zisk_prover.ZisKProver.init(allocator, .{
                        .cargo_zisk_path = options.cargo_zisk_path,
                    });
                },
                .ligero => {
                    self.ligero_prov = try ligero_prover.LigeroProver.init(allocator, .{
                        .webgpu_prover_path = options.webgpu_prover_path,
                        .webgpu_verifier_path = options.webgpu_verifier_path,
                        .shader_path = options.shader_path,
                    });
                },
            }
        }

        return self;
    }

    /// Free runtime resources
    pub fn deinit(self: *Self) void {
        self.allocator.free(self.guest_binary);
        if (self.zisk_exec) |*e| e.deinit();
        if (self.zisk_prov) |*p| p.deinit();
        if (self.ligero_exec) |*e| e.deinit();
        if (self.ligero_prov) |*p| p.deinit();
    }

    /// Create an Input builder for this runtime's backend.
    /// Use this to prepare inputs with proper encoding.
    pub fn createInput(self: *Self) host.Input {
        return host.Input.initWithBackend(self.allocator, self.options.backend.toHostBackend());
    }

    /// Execute the guest program without generating a proof.
    ///
    /// For backends that support public/private separation (Ligero):
    /// - public_input: Data visible to the verifier
    /// - private_input: Witness data kept secret
    ///
    /// For backends without separation (ZisK):
    /// - public_input: Ignored (can be null or empty)
    /// - private_input: All input data
    ///
    /// Use createInput() to build properly encoded inputs.
    pub fn execute(self: *Self, public_input: ?[]const u8, private_input: []const u8) !ExecutionResult {
        return switch (self.options.backend) {
            .zisk => try self.executeZisk(public_input, private_input),
            .ligero => try self.executeLigero(public_input, private_input),
        };
    }

    /// Execute with a single pre-encoded input (backward compatible).
    /// The input should be fully encoded bytes (including any backend-specific headers).
    pub fn executeWithInput(self: *Self, input: []const u8) !ExecutionResult {
        // For backward compatibility, pass the entire input as-is
        // This assumes the input is already properly encoded for the backend
        return switch (self.options.backend) {
            .zisk => try self.executeZiskRaw(input),
            .ligero => try self.executeLigeroRaw(input),
        };
    }

    // Internal: Execute on ZisK with public/private separation
    fn executeZisk(self: *Self, public_input: ?[]const u8, private_input: []const u8) !ExecutionResult {
        // ZisK doesn't distinguish public/private - combine into single input
        const combined = try self.encodeZiskInput(public_input, private_input);
        defer self.allocator.free(combined);

        return self.executeZiskRaw(combined);
    }

    // Internal: Execute on ZisK with raw pre-encoded input
    fn executeZiskRaw(self: *Self, input: []const u8) !ExecutionResult {
        var exec_result = try self.zisk_exec.?.execute(self.guest_binary, input);

        // Convert OutputData to bytes for host.Output
        const output_bytes = try self.outputDataToBytes(exec_result.outputs);
        defer self.allocator.free(output_bytes);

        // Free the original OutputData values
        exec_result.outputs.deinit();

        // Create backend-aware Output
        const output = try host.Output.fromBytesWithBackend(
            self.allocator,
            output_bytes,
            .zisk,
        );

        return ExecutionResult{
            .allocator = self.allocator,
            .output = output,
            .cycles = exec_result.cycles,
            .stdout = exec_result.stdout,
            .stderr = exec_result.stderr,
        };
    }

    // Internal: Execute on Ligero with public/private separation
    fn executeLigero(self: *Self, public_input: ?[]const u8, private_input: []const u8) !ExecutionResult {
        // Ligero format: [pub_len:u64][pub_data][priv_len:u64][priv_data]
        const combined = try self.encodeLigeroInput(public_input, private_input);
        defer self.allocator.free(combined);

        return self.executeLigeroRaw(combined);
    }

    // Internal: Execute on Ligero with raw pre-encoded input
    fn executeLigeroRaw(self: *Self, input: []const u8) !ExecutionResult {
        var exec_result = try self.ligero_exec.?.execute(self.guest_binary, input);

        // Convert OutputData to bytes for host.Output
        const output_bytes = try self.outputDataToBytes(exec_result.outputs);
        defer self.allocator.free(output_bytes);

        // Free the original OutputData values
        exec_result.outputs.deinit();

        // Create backend-aware Output
        const output = try host.Output.fromBytesWithBackend(
            self.allocator,
            output_bytes,
            .ligero,
        );

        return ExecutionResult{
            .allocator = self.allocator,
            .output = output,
            .cycles = exec_result.cycles,
            .stdout = exec_result.stdout,
            .stderr = exec_result.stderr,
        };
    }

    // Internal: Encode input for ZisK (16-byte header + data)
    fn encodeZiskInput(self: *Self, public_input: ?[]const u8, private_input: []const u8) ![]const u8 {
        const pub_len = if (public_input) |p| p.len else 0;
        const total_data_len = pub_len + private_input.len;

        // ZisK format: 8 reserved + 8 size + data
        const result = try self.allocator.alloc(u8, 16 + total_data_len);
        errdefer self.allocator.free(result);

        @memset(result[0..8], 0); // Reserved
        std.mem.writeInt(u64, result[8..16], total_data_len, .little);

        if (public_input) |p| {
            @memcpy(result[16..][0..pub_len], p);
        }
        @memcpy(result[16 + pub_len ..], private_input);

        return result;
    }

    // Internal: Encode input for Ligero
    fn encodeLigeroInput(self: *Self, public_input: ?[]const u8, private_input: []const u8) ![]const u8 {
        const pub_len = if (public_input) |p| p.len else 0;
        const total = 8 + pub_len + 8 + private_input.len;

        const result = try self.allocator.alloc(u8, total);
        errdefer self.allocator.free(result);

        var offset: usize = 0;

        std.mem.writeInt(u64, result[offset..][0..8], pub_len, .little);
        offset += 8;

        if (public_input) |p| {
            @memcpy(result[offset..][0..pub_len], p);
            offset += pub_len;
        }

        std.mem.writeInt(u64, result[offset..][0..8], private_input.len, .little);
        offset += 8;

        @memcpy(result[offset..], private_input);

        return result;
    }

    // Internal: Convert OutputData to bytes for host.Output
    fn outputDataToBytes(self: *Self, data: OutputData) ![]const u8 {
        const size = 4 + (data.count * 4);
        const bytes = try self.allocator.alloc(u8, size);

        std.mem.writeInt(u32, bytes[0..4], data.count, .little);
        for (0..data.count) |i| {
            const offset = 4 + (i * 4);
            std.mem.writeInt(u32, bytes[offset..][0..4], data.values[i], .little);
        }

        return bytes;
    }

    /// Execute the guest program and generate a cryptographic proof.
    ///
    /// For backends that support public/private separation (Ligero):
    /// - public_input: Data visible to the verifier
    /// - private_input: Witness data kept secret
    ///
    /// For backends without separation (ZisK):
    /// - public_input: Ignored (can be null or empty)
    /// - private_input: All input data
    pub fn prove(self: *Self, public_input: ?[]const u8, private_input: []const u8) !ProofResult {
        if (!self.options.enable_proving) {
            return error.ProvingNotEnabled;
        }

        return switch (self.options.backend) {
            .zisk => try self.proveZisk(public_input, private_input),
            .ligero => try self.proveLigero(public_input, private_input),
        };
    }

    /// Prove with a single pre-encoded input (backward compatible).
    pub fn proveWithInput(self: *Self, input: []const u8) !ProofResult {
        if (!self.options.enable_proving) {
            return error.ProvingNotEnabled;
        }

        return switch (self.options.backend) {
            .zisk => try self.proveZiskRaw(input),
            .ligero => try self.proveLigeroRaw(input),
        };
    }

    // Internal: Prove on ZisK with public/private separation
    fn proveZisk(self: *Self, public_input: ?[]const u8, private_input: []const u8) !ProofResult {
        const combined = try self.encodeZiskInput(public_input, private_input);
        defer self.allocator.free(combined);
        return self.proveZiskRaw(combined);
    }

    // Internal: Prove on ZisK with raw input
    fn proveZiskRaw(self: *Self, input: []const u8) !ProofResult {
        var prove_result = try self.zisk_prov.?.prove(self.guest_binary, input);

        // Convert OutputData to bytes for host.Output
        const output_bytes = try self.outputDataToBytes(prove_result.outputs);
        defer self.allocator.free(output_bytes);

        // Free the original OutputData values
        prove_result.outputs.deinit();

        const output = try host.Output.fromBytesWithBackend(
            self.allocator,
            output_bytes,
            .zisk,
        );

        return ProofResult{
            .allocator = self.allocator,
            .output = output,
            .proof = prove_result.proof,
            .proof_time_ms = prove_result.proof_time_ms,
            .stdout = prove_result.stdout,
            .stderr = prove_result.stderr,
        };
    }

    // Internal: Prove on Ligero with public/private separation
    fn proveLigero(self: *Self, public_input: ?[]const u8, private_input: []const u8) !ProofResult {
        const combined = try self.encodeLigeroInput(public_input, private_input);
        defer self.allocator.free(combined);
        return self.proveLigeroRaw(combined);
    }

    // Internal: Prove on Ligero with raw input
    fn proveLigeroRaw(self: *Self, input: []const u8) !ProofResult {
        var prove_result = try self.ligero_prov.?.prove(self.guest_binary, input);

        // Convert OutputData to bytes for host.Output
        const output_bytes = try self.outputDataToBytes(prove_result.outputs);
        defer self.allocator.free(output_bytes);

        // Free the original OutputData values
        prove_result.outputs.deinit();

        const output = try host.Output.fromBytesWithBackend(
            self.allocator,
            output_bytes,
            .ligero,
        );

        return ProofResult{
            .allocator = self.allocator,
            .output = output,
            .proof = prove_result.proof,
            .proof_time_ms = prove_result.proof_time_ms,
            .stdout = prove_result.stdout,
            .stderr = prove_result.stderr,
        };
    }

    /// Verify a proof
    pub fn verify(self: *Self, proof: *const Proof, public_inputs: ?[]const u8) !bool {
        if (!self.options.enable_proving) {
            return error.ProvingNotEnabled;
        }

        return switch (self.options.backend) {
            .zisk => try self.zisk_prov.?.verify(proof, public_inputs),
            .ligero => try self.ligero_prov.?.verify(proof, public_inputs),
        };
    }

    /// Get the backend this runtime is configured for
    pub fn getBackend(self: *const Self) Backend {
        return self.options.backend;
    }
};

// Re-export executor and prover types for direct use
pub const ZisKExecutor = zisk_executor.ZisKExecutor;
pub const ZisKProver = zisk_prover.ZisKProver;
pub const LigeroExecutor = ligero_executor.LigeroExecutor;
pub const LigeroProver = ligero_prover.LigeroProver;
